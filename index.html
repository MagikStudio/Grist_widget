<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Checkbox Filter Widget for Grist</title>
  <script src="https://docs.getgrist.com/grist-plugin-api.js"></script>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    :root { --gap: 8px; }
    html, body {
      margin: 0; padding: 0; height: 100%;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background-color: var(--grist-theme-page-bg);
      color: var(--grist-theme-text);
      -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
    }
    #container { position: relative; height: 100%; padding: 8px; box-sizing: border-box; }
    #controls { display:flex; gap:8px; align-items:center; margin-bottom:8px; }
    #search { flex:1; padding:6px 8px; border-radius:6px; border:1px solid var(--grist-theme-table-body-border); background:var(--grist-theme-page-panels-main-panel-bg); color:var(--grist-theme-text); font-size:13px; }
    #dropdown { width:100%; height:calc(100% - 46px); box-sizing:border-box; margin:0; padding:8px; overflow-y:auto; background-color:var(--grist-theme-page-panels-main-panel-bg); border:1px solid var(--grist-theme-table-body-border); color:var(--grist-theme-text); border-radius:6px; font-size:13px; }
    #error { display:none; position:absolute; top:8px; right:8px; width:48%; height:calc(100% - 16px); background:rgba(208,2,27,0.9); color:white; padding:8px; font-size:12px; overflow-y:auto; box-sizing:border-box; border-radius:6px; z-index:5; }
    #checkbox-values { display:block; }
    #dropdown label { display:flex; align-items:center; gap:8px; padding:6px 4px; cursor:pointer; user-select:none; border-radius:4px; }
    #dropdown label:hover { background: rgba(0,0,0,0.03); }
    #dropdown input[type="checkbox"] { transform:scale(1); width:16px; height:16px; }
    #config { display:none; padding:8px; box-sizing:border-box; gap:8px; align-items:center; background:transparent; }
    #config label { margin-right:6px; }
    #config input[type="text"] { padding:6px 8px; border-radius:6px; border:1px solid var(--grist-theme-table-body-border); background:var(--grist-theme-page-panels-main-panel-bg); color:var(--grist-theme-text); font-size:13px; }
    #save { padding:6px 10px; border-radius:6px; border:0; cursor:pointer; background:var(--grist-theme-cursor); color:var(--grist-theme-page-bg); font-weight:600; }
    @media (max-width:480px) { #error { display:none; } #dropdown { height: calc(100% - 80px); } }
  </style>
</head>
<body>
  <div id="container">
    <div id="controls" aria-hidden="false">
      <input id="search" placeholder="Rechercher..." type="search" aria-label="Rechercher options">
      <label style="display:flex;align-items:center;gap:8px;">
        <input id="select-all" type="checkbox" aria-label="Tout sélectionner">
        <span style="font-size:13px;">Tout sélectionner</span>
      </label>
    </div>

    <div id="dropdown" role="list" tabindex="0" aria-label="Dropdown filter"></div>
    <div id="error" role="alert" aria-live="polite"></div>
  </div>

  <div id="config" style="display: none;">
    <label for="sessionid">Session ID:</label>
    <input type="text" id="sessionid" placeholder="optionnel">
    <button id="save">Apply</button>
  </div>

  <script>
  (function () {
    let currentoptions = [];
    let allRecords = []; // contient uniquement les records fournis par onRecords (vue actuelle)
    let sessionID = "";
    let column = "";

    function $(id){ return document.getElementById(id); }

    function showError(msg){
      const el = $('error');
      if(!el) return;
      if(!msg){ el.style.display='none'; el.innerHTML=''; }
      else { el.style.display='block'; el.innerHTML = msg; }
    }

    // restore mais restreint aux options actuelles (uniqoptions)
    function restoreSelectionFromSession(uniqoptions){
      if(!sessionID) return [];
      const raw = sessionStorage.getItem(sessionID + "_Dropdownfilter_Item");
      if(raw === null) return [];
      try {
        const parsed = JSON.parse(raw);
        if(Array.isArray(parsed)) return parsed.map(v=>String(v)).filter(v => uniqoptions.includes(String(v)));
        if(typeof parsed === 'string' && uniqoptions.includes(parsed)) return [parsed];
      } catch(e){
        if(raw.length > 0 && uniqoptions.includes(raw)) return [raw];
      }
      return [];
    }

    function getAllCheckboxes(){
      const wrapper = $('checkbox-values');
      if(!wrapper) return [];
      return Array.from(wrapper.querySelectorAll('input[type="checkbox"].value-checkbox'));
    }

    // ne retourne que les checkboxes visibles (après recherche)
    function getVisibleCheckboxes(){
      return getAllCheckboxes().filter(cb => {
        const label = cb.closest('label');
        return !label || label.style.display !== 'none';
      });
    }

    // Met à jour l'état du checkbox "select-all" en tenant compte uniquement des checkbox visibles
    function updateSelectAllState(){
      const top = $('select-all');
      if(!top) return;
      const visible = getVisibleCheckboxes();
      if(visible.length === 0){ top.checked = false; top.indeterminate = false; return; }
      const checked = visible.filter(b=>b.checked).length;
      if(checked === 0){ top.checked = false; top.indeterminate = false; }
      else if(checked === visible.length){ top.checked = true; top.indeterminate = false; }
      else { top.checked = false; top.indeterminate = true; }
    }

    // applique le filtre de recherche (cache les labels non-matching)
    function applySearchFilter(){
      const q = String($('search').value || '').trim().toLowerCase();
      const wrapper = $('checkbox-values');
      if(!wrapper) return;
      const labels = Array.from(wrapper.querySelectorAll('label'));
      labels.forEach(label => {
        const text = (label.textContent || '').toLowerCase();
        label.style.display = (q === '' || text.indexOf(q) !== -1) ? 'flex' : 'none';
      });
      updateSelectAllState();
    }

    // applique la sélection depuis l'UI: ne prend que les valeurs cochées ET visibles
    function applySelectionFromUI(){
      const visible = getVisibleCheckboxes();
      const checked = visible.filter(i=>i.checked).map(i=>String(i.value));
      // on sauvegarde la sélection (toutes values cochées, même si non visibles? ici on sauvegarde toutes cochées, visibles uniquement)
      if(sessionID) sessionStorage.setItem(sessionID + "_Dropdownfilter_Item", JSON.stringify(checked));
      // ne sélectionner que les lignes qui sont dans allRecords (vue actuelle)
      const rows = allRecords
        .filter(item => {
          const itemVal = item && item[column] !== undefined && item[column] !== null ? String(item[column]) : '';
          return checked.includes(itemVal);
        })
        .map(({id}) => id);
      grist.setSelectedRows(rows.length > 0 ? rows : null);
      updateSelectAllState();
    }

    // render checkboxes based on options array (options derives from mapped records passed by onRecords)
    function renderCheckboxes(options){
      const normalized = Array.isArray(options) ? options.filter(o=>o!==null && o!==undefined).map(o=>String(o)) : [];
      const uniqoptions = Array.from(new Set(normalized)).sort();
      const container = $('dropdown');
      if(!container) return;
      container.innerHTML = '';

      const listWrapper = document.createElement('div');
      listWrapper.id = 'checkbox-values';
      container.appendChild(listWrapper);

      // restaurer uniquement pour les valeurs présentes dans uniqoptions
      let currentSelections = restoreSelectionFromSession(uniqoptions);

      if(uniqoptions.length === 0){
        const p = document.createElement('div');
        p.textContent = 'No options available';
        listWrapper.appendChild(p);
        grist.setSelectedRows(null);
        updateSelectAllState();
        return;
      }

      uniqoptions.forEach(opt=>{
        const id = 'cb_' + Math.random().toString(36).slice(2,9);
        const label = document.createElement('label');
        label.htmlFor = id;
        label.style.display = 'flex';
        label.style.alignItems = 'center';
        label.style.gap = '8px';
        label.style.padding = '6px 4px';
        label.style.cursor = 'pointer';
        label.style.borderRadius = '4px';

        const input = document.createElement('input');
        input.type = 'checkbox';
        input.className = 'value-checkbox';
        input.id = id;
        input.value = String(opt);
        input.setAttribute('aria-checked','false');

        if(currentSelections.includes(String(opt))){
          input.checked = true;
          input.setAttribute('aria-checked','true');
        }

        input.addEventListener('change', function(){
          input.setAttribute('aria-checked', input.checked ? 'true' : 'false');
          applySelectionFromUI();
        });

        const span = document.createElement('span');
        span.textContent = String(opt);

        label.appendChild(input);
        label.appendChild(span);
        listWrapper.appendChild(label);
      });

      // appliquer sélection initiale : ne select que les rows visibles dans allRecords
      applySelectionFromUI();

      currentoptions = [''].concat(uniqoptions);
      updateSelectAllState();
    }

    // save option helper
    function saveOption(){
      const sid = String($('sessionid').value || '').trim();
      if(grist && grist.widgetApi && typeof grist.widgetApi.setOption === 'function'){
        grist.widgetApi.setOption('sessionid', sid);
      } else if(grist && typeof grist.setOption === 'function'){
        grist.setOption('sessionid', sid);
      } else {
        console.warn('setOption API not available on grist object');
      }
    }

    // init UI handlers: search, select-all, save
    function initUIHandlers(){
      const saveBtn = $('save');
      if(saveBtn) saveBtn.addEventListener('click', saveOption);

      const search = $('search');
      if(search) search.addEventListener('input', applySearchFilter);

      const top = $('select-all');
      if(top){
        top.addEventListener('change', function(e){
          const checked = e.target.checked;
          // n'affecter que les checkboxes visibles
          const visible = getVisibleCheckboxes();
          visible.forEach(cb => { cb.checked = checked; cb.setAttribute('aria-checked', checked ? 'true' : 'false'); });
          applySelectionFromUI();
        });
      }
    }

    // lifecycle with Grist
    function initGrist(){
      initUIHandlers();

      if(!window.grist){
        showError('Grist API not available');
        return;
      }

      grist.ready({
        columns: [{ name: "OptionsToSelect", title: 'Options to select', type: 'Any' }],
        requiredAccess: 'read table',
        allowSelectBy: true,
        onEditOptions(){
          $('container').style.display = 'none';
          $('config').style.display = '';
          $('sessionid').value = sessionID || '';
        }
      });

      grist.onOptions((customOptions, _) => {
        customOptions = customOptions || {};
        sessionID = customOptions.sessionid || "";
        $('container').style.display = '';
        $('config').style.display = 'none';
      });

      grist.onRecords(function(records, mappings){
        if(!records || records.length === 0){
          // vue vide : vider
          allRecords = [];
          column = mappings && mappings.OptionsToSelect;
          showError("No records received");
          renderCheckboxes([]);
          grist.setSelectedRows(null);
          return;
        }

        // stocker uniquement les enregistrements fournis par la vue (évite bannière rouge)
        allRecords = records;
        column = mappings && mappings.OptionsToSelect;

        const mapped = grist.mapColumnNames(records || []);
        showError("");
        const options = mapped.map(record => record.OptionsToSelect).filter(option => option !== null && option !== undefined);
        if(options.length === 0) showError("No valid options found");
        renderCheckboxes(options);
      });
    }

    // start
    document.addEventListener('DOMContentLoaded', initGrist);
  })();
  </script>
</body>
</html>
